import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { ImageGenerator, getDefaultModelId } from '$lib/image-generator';

const mockGenerateContent = vi.fn();
const mockGenerateImages = vi.fn();
const mockUpload = vi.fn();
const mockBatchesCreate = vi.fn();
const mockBatchesGet = vi.fn();

vi.mock('@google/genai', () => {
  return {
    GoogleGenAI: class {
      constructor() {
        return {
          models: {
            generateContent: mockGenerateContent,
            generateImages: mockGenerateImages,
          },
          files: {
            upload: mockUpload,
          },
          batches: {
            create: mockBatchesCreate,
            get: mockBatchesGet,
          },
        };
      }
    },
  };
});

const globalFetch = global.fetch;
const mockFetch = vi.fn();

describe('lib/image-generator', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = mockFetch;
  });

  afterEach(() => {
    global.fetch = globalFetch;
  });

  describe('getDefaultModelId', () => {
    it('should return a default model', () => {
      expect(getDefaultModelId()).toBeDefined();
    });

    it('should return a batch supported model if requested', () => {
      const id = getDefaultModelId(true);
      expect(id).toContain('gemini');
    });

    it('should fallback if no default model', () => {
      // If MODELS list changed, just ensure it returns string
      expect(getDefaultModelId()).toBeTypeOf('string');
    });
  });

  describe('ImageGenerator', () => {
    const gen = new ImageGenerator(
      'key',
      'System Prompt',
      'gemini-3-pro-image-preview',
    );
    const imagenGen = new ImageGenerator(
      'key',
      'System Prompt',
      'imagen-4.0-generate-001',
    );
    const defaultGen = new ImageGenerator('key', 'System Prompt');

    describe('generate', () => {
      it('should calls generateWithGemini for Gemini models', async () => {
        mockGenerateContent.mockResolvedValue({
          candidates: [
            {
              finishReason: 'STOP',
              content: {
                parts: [{ inlineData: { data: 'BASE64DATA' } }],
              },
            },
          ],
        });

        const result = await gen.generate('User Prompt');
        expect(mockGenerateContent).toHaveBeenCalled();
        expect(result).toContain('BASE64DATA');
      });

      it('generateWithGemini handles images input', async () => {
        mockGenerateContent.mockResolvedValue({
          candidates: [
            {
              finishReason: 'STOP',
              content: {
                parts: [{ inlineData: { data: 'IMG' } }],
              },
            },
          ],
        });
        await gen.generate('prompt', [
          { base64: 'AA', mimeType: 'image/jpeg' },
        ]);
        expect(mockGenerateContent).toHaveBeenCalled();
      });

      it('should calls generateWithImagen for Imagen models', async () => {
        mockGenerateImages.mockResolvedValue({
          generatedImages: [{ image: { imageBytes: 'IMAGENBYTES' } }],
        });

        const result = await imagenGen.generate('User Prompt');
        expect(mockGenerateImages).toHaveBeenCalled();
        expect(result).toContain('IMAGENBYTES');
      });

      it('should throw if Imagen returns no images', async () => {
        mockGenerateImages.mockResolvedValue({ generatedImages: [] });
        await expect(imagenGen.generate('prompt')).rejects.toThrow(
          'No image generated by Imagen',
        );
      });

      it('should handle errors gracefully', async () => {
        mockGenerateContent.mockRejectedValue(new Error('API Fail'));
        await expect(gen.generate('fail')).rejects.toThrow(
          'Error generating image: API Fail',
        );
      });

      it('should throw if no candidates', async () => {
        mockGenerateContent.mockResolvedValue({});
        await expect(gen.generate('empty')).rejects.toThrow('No candidates');
      });

      it('should throw if no response content', async () => {
        mockGenerateContent.mockResolvedValue({
          candidates: [{ finishReason: 'STOP', content: {} }],
        });
        await expect(gen.generate('empty')).rejects.toThrow(
          'No response content',
        );
      });

      it('should throw if no image data (text only response)', async () => {
        mockGenerateContent.mockResolvedValue({
          candidates: [
            {
              finishReason: 'STOP',
              content: { parts: [{ text: 'No image' }] },
            },
          ],
        });
        await expect(gen.generate('empty')).rejects.toThrow('No image data');
      });
    });

    describe('Batch Operations', () => {
      it('enqueue should upload file and create batch', async () => {
        mockUpload.mockResolvedValue({ name: 'files/123' });
        mockBatchesCreate.mockResolvedValue({ name: 'jobs/456' });

        const result = await gen.enqueue(['p1', 'p2'], 'JobName');
        expect(result).toEqual({ name: 'jobs/456' });
      });

      it('enqueue should throw if upload name missing', async () => {
        mockUpload.mockResolvedValue({});
        await expect(gen.enqueue(['p1'])).rejects.toThrow('Failed to upload');
      });

      it('enqueue should throw for Imagen models', async () => {
        await expect(imagenGen.enqueue(['p1'])).rejects.toThrow(
          'not supported',
        );
      });

      it('query should call batches.get', async () => {
        await gen.query('jobs/123');
        expect(mockBatchesGet).toHaveBeenCalledWith({ name: 'jobs/123' });
      });

      it('get should download and parse results', async () => {
        const jsonLine = JSON.stringify({
          response: {
            candidates: [
              {
                content: {
                  parts: [{ inlineData: { data: 'IMGDATA' } }],
                },
              },
            ],
          },
        });
        mockFetch.mockResolvedValue({
          ok: true,
          text: async () => jsonLine + '\n' + jsonLine,
        });

        const results = await gen.get('files/out');
        expect(results).toHaveLength(2);
      });

      it('get should handle batch item errors', async () => {
        const jsonLine = JSON.stringify({
          error: { message: 'Failed item' },
        });
        mockFetch.mockResolvedValue({
          ok: true,
          text: async () => jsonLine,
        });
        const consoleSpy = vi
          .spyOn(console, 'error')
          .mockImplementation(() => {});
        const results = await gen.get('files/err');
        expect(results).toHaveLength(0);
        expect(consoleSpy).toHaveBeenCalledWith(
          expect.stringContaining('Batch item error'),
        );
        consoleSpy.mockRestore();
      });

      it('get should handle parse error', async () => {
        mockFetch.mockResolvedValue({
          ok: true,
          text: async () => 'INVALID JSON',
        });
        const consoleSpy = vi
          .spyOn(console, 'error')
          .mockImplementation(() => {});
        await gen.get('files/badjson');
        expect(consoleSpy).toHaveBeenCalledWith(
          expect.stringContaining('Failed to parse result line'),
          expect.anything(),
        );
        consoleSpy.mockRestore();
      });

      it('get should handle fetch errors', async () => {
        mockFetch.mockResolvedValue({
          ok: false,
          statusText: 'Not Found',
        });
        await expect(gen.get('files/bad')).rejects.toThrow(
          'Failed to download results',
        );
      });
    });
  });
});
